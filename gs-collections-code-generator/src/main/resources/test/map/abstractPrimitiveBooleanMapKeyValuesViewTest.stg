import "copyright.stg"
import "primitiveHashCode.stg"
import "primitiveLiteral.stg"
import "primitiveEquals.stg"

skipBoolean() ::= "true"

isTest() ::= "true"

targetPath() ::= "com/gs/collections/impl/map/primitive"

fileName(primitive) ::= "Abstract<primitive.name>BooleanMapKeyValuesViewTestCase"

class(primitive) ::= <<
<body(primitive.type, primitive.name, primitive.wrapperName)>
>>

body(type, name, wrapperName) ::= <<
<copyright()>

package com.gs.collections.impl.map.primitive;

import java.util.Iterator;
import java.util.NoSuchElementException;
import java.util.concurrent.atomic.AtomicInteger;

import com.gs.collections.api.BooleanIterable;
import com.gs.collections.api.ByteIterable;
import com.gs.collections.api.CharIterable;
import com.gs.collections.api.DoubleIterable;
import com.gs.collections.api.FloatIterable;
import com.gs.collections.api.IntIterable;
import com.gs.collections.api.LongIterable;
import com.gs.collections.api.RichIterable;
import com.gs.collections.api.ShortIterable;
import com.gs.collections.api.bag.MutableBag;
import com.gs.collections.api.block.function.Function;
import com.gs.collections.api.block.function.Function0;
import com.gs.collections.api.block.function.Function2;
import com.gs.collections.api.block.function.primitive.BooleanFunction;
import com.gs.collections.api.block.function.primitive.ByteFunction;
import com.gs.collections.api.block.function.primitive.CharFunction;
import com.gs.collections.api.block.function.primitive.DoubleFunction;
import com.gs.collections.api.block.function.primitive.DoubleObjectToDoubleFunction;
import com.gs.collections.api.block.function.primitive.FloatFunction;
import com.gs.collections.api.block.function.primitive.FloatObjectToFloatFunction;
import com.gs.collections.api.block.function.primitive.IntFunction;
import com.gs.collections.api.block.function.primitive.IntObjectToIntFunction;
import com.gs.collections.api.block.function.primitive.LongFunction;
import com.gs.collections.api.block.function.primitive.LongObjectToLongFunction;
import com.gs.collections.api.block.function.primitive.ShortFunction;
import com.gs.collections.api.block.procedure.Procedure2;
import com.gs.collections.api.block.procedure.primitive.ObjectIntProcedure;
import com.gs.collections.api.list.MutableList;
import com.gs.collections.api.map.MapIterable;
import com.gs.collections.api.map.MutableMap;
import com.gs.collections.api.map.primitive.<name>BooleanMap;
import com.gs.collections.api.map.sorted.MutableSortedMap;
import com.gs.collections.api.multimap.Multimap;
import com.gs.collections.api.partition.PartitionIterable;
import com.gs.collections.api.set.MutableSet;
import com.gs.collections.api.set.sorted.MutableSortedSet;
import com.gs.collections.api.tuple.Pair;
import com.gs.collections.api.tuple.primitive.<name>BooleanPair;
import com.gs.collections.impl.bag.mutable.HashBag;
import com.gs.collections.impl.bag.mutable.primitive.BooleanHashBag;
import com.gs.collections.impl.bag.mutable.primitive.ByteHashBag;
import com.gs.collections.impl.bag.mutable.primitive.CharHashBag;
import com.gs.collections.impl.bag.mutable.primitive.DoubleHashBag;
import com.gs.collections.impl.bag.mutable.primitive.FloatHashBag;
import com.gs.collections.impl.bag.mutable.primitive.IntHashBag;
import com.gs.collections.impl.bag.mutable.primitive.LongHashBag;
import com.gs.collections.impl.bag.mutable.primitive.ShortHashBag;
import com.gs.collections.impl.block.factory.Comparators;
import com.gs.collections.impl.block.factory.Functions;
import com.gs.collections.impl.block.factory.Functions0;
import com.gs.collections.impl.block.factory.Predicates;
import com.gs.collections.impl.block.factory.Predicates2;
import com.gs.collections.impl.block.procedure.CollectionAddProcedure;
import com.gs.collections.impl.factory.Bags;
import com.gs.collections.impl.factory.Lists;
import com.gs.collections.impl.list.Interval;
import com.gs.collections.impl.list.mutable.FastList;
import com.gs.collections.impl.map.mutable.UnifiedMap;
import com.gs.collections.impl.map.sorted.mutable.TreeSortedMap;
import com.gs.collections.impl.set.mutable.UnifiedSet;
import com.gs.collections.impl.set.sorted.mutable.TreeSortedSet;
import com.gs.collections.impl.test.Verify;
import com.gs.collections.impl.tuple.Tuples;
import com.gs.collections.impl.tuple.primitive.PrimitiveTuples;
import org.junit.Assert;
import org.junit.Test;

/**
 * Abstract JUnit test for {@link <name>BooleanMap#keyValuesView()}.
 * This file was automatically generated from template file abstractPrimitiveBooleanMapKeyValuesViewTest.stg.
 */
public abstract class Abstract<name>BooleanMapKeyValuesViewTestCase
{
    public abstract <name>BooleanMap newWithKeysValues(<type> key1, boolean value1, <type> key2, boolean value2, <type> key3, boolean value3);

    public abstract <name>BooleanMap newWithKeysValues(<type> key1, boolean value1, <type> key2, boolean value2);

    public abstract <name>BooleanMap newWithKeysValues(<type> key1, boolean value1);

    public abstract <name>BooleanMap newEmpty();

    public RichIterable\<<name>BooleanPair> newWith()
    {
        return this.newEmpty().keyValuesView();
    }

    public RichIterable\<<name>BooleanPair> newWith(<type> key1, boolean value1)
    {
        return this.newWithKeysValues(key1, value1).keyValuesView();
    }

    public RichIterable\<<name>BooleanPair> newWith(<type> key1, boolean value1, <type> key2, boolean value2)
    {
        return this.newWithKeysValues(key1, value1, key2, value2).keyValuesView();
    }

    public RichIterable\<<name>BooleanPair> newWith(<type> key1, boolean value1, <type> key2, boolean value2, <type> key3, boolean value3)
    {
        return this.newWithKeysValues(key1, value1, key2, value2, key3, value3).keyValuesView();
    }

    @Test
    public void containsAllIterable()
    {
        RichIterable\<<name>BooleanPair> collection = this.newWith(<(literal.(type))("1")>, false, <(literal.(type))("2")>, true, <(literal.(type))("3")>, false);
        Assert.assertTrue(collection.containsAllIterable(FastList.newListWith(PrimitiveTuples.pair(<(literal.(type))("1")>, false), PrimitiveTuples.pair(<(literal.(type))("2")>, true))));
        Assert.assertFalse(collection.containsAllIterable(FastList.newListWith(PrimitiveTuples.pair(<(literal.(type))("1")>, false), PrimitiveTuples.pair(<(literal.(type))("1")>, true))));
    }

    @Test
    public void containsAllArray()
    {
        RichIterable\<<name>BooleanPair> collection = this.newWith(<(literal.(type))("1")>, false, <(literal.(type))("2")>, true, <(literal.(type))("3")>, false);
        Assert.assertTrue(collection.containsAllArguments(PrimitiveTuples.pair(<(literal.(type))("1")>, false), PrimitiveTuples.pair(<(literal.(type))("2")>, true)));
        Assert.assertFalse(collection.containsAllArguments(PrimitiveTuples.pair(<(literal.(type))("1")>, false), PrimitiveTuples.pair(1, 5L)));
    }

    @Test
    public void forEach()
    {
        MutableList\<<name>BooleanPair> result = Lists.mutable.of();
        RichIterable\<<name>BooleanPair> collection = this.newWith(<(literal.(type))("1")>, false, <(literal.(type))("2")>, true, <(literal.(type))("3")>, false);
        collection.forEach(CollectionAddProcedure.on(result));
        Verify.assertSize(3, result);
        Verify.assertContainsAll(result, PrimitiveTuples.pair(<(literal.(type))("1")>, false), PrimitiveTuples.pair(<(literal.(type))("2")>, true), PrimitiveTuples.pair(<(literal.(type))("3")>, false));

        MutableList\<<name>BooleanPair> result2 = Lists.mutable.of();
        RichIterable\<<name>BooleanPair> collection2 = this.newWith(<(literal.(type))("0")>, false, <(literal.(type))("2")>, true, <(literal.(type))("3")>, false);
        collection2.forEach(CollectionAddProcedure.on(result2));
        Verify.assertSize(3, result2);
        Verify.assertContainsAll(result2, PrimitiveTuples.pair(<(literal.(type))("0")>, false), PrimitiveTuples.pair(<(literal.(type))("2")>, true), PrimitiveTuples.pair(<(literal.(type))("3")>, false));
    }

    @Test
    public void forEachWith()
    {
        final MutableBag\<<name>BooleanPair> result = Bags.mutable.of();
        final MutableBag\<Integer> result2 = Bags.mutable.of();
        RichIterable\<<name>BooleanPair> collection = this.newWith(<(literal.(type))("1")>, false, <(literal.(type))("2")>, true, <(literal.(type))("3")>, false);
        collection.forEachWith(new Procedure2\<<name>BooleanPair, Integer>()
        {
            public void value(<name>BooleanPair argument1, Integer argument2)
            {
                result.add(argument1);
                result2.add(argument2);
            }
        }, 0);

        Assert.assertEquals(Bags.immutable.of(PrimitiveTuples.pair(<(literal.(type))("1")>, false), PrimitiveTuples.pair(<(literal.(type))("2")>, true), PrimitiveTuples.pair(<(literal.(type))("3")>, false)), result);
        Assert.assertEquals(Bags.immutable.of(0, 0, 0), result2);
    }

    @Test
    public void forEachWithIndex()
    {
        final MutableBag\<<name>BooleanPair> elements = Bags.mutable.of();
        final MutableBag\<Integer> indexes = Bags.mutable.of();
        RichIterable\<<name>BooleanPair> collection = this.newWith(<(literal.(type))("1")>, false, <(literal.(type))("0")>, true, <(literal.(type))("3")>, false);
        collection.forEachWithIndex(new ObjectIntProcedure\<<name>BooleanPair>()
        {
            public void value(<name>BooleanPair object, int index)
            {
                elements.add(object);
                indexes.add(index);
            }
        });
        Assert.assertEquals(Bags.mutable.of(PrimitiveTuples.pair(<(literal.(type))("1")>, false), PrimitiveTuples.pair(<(literal.(type))("0")>, true), PrimitiveTuples.pair(<(literal.(type))("3")>, false)), elements);
        Assert.assertEquals(Bags.mutable.of(0, 1, 2), indexes);
    }

    @Test
    public void select()
    {
        MutableList\<<name>BooleanPair> result = this.newWith(<(literal.(type))("1")>, false, <(literal.(type))("2")>, true, <(literal.(type))("3")>, false).select(Predicates.equal(PrimitiveTuples.pair(<(literal.(type))("2")>, true))).toList();
        Verify.assertContains(PrimitiveTuples.pair(<(literal.(type))("2")>, true), result);
        Verify.assertNotContains(PrimitiveTuples.pair(<(literal.(type))("1")>, false), result);
        Verify.assertNotContains(PrimitiveTuples.pair(<(literal.(type))("3")>, false), result);
    }

    @Test
    public void selectWith()
    {
        MutableList\<<name>BooleanPair> result = this.newWith(<(literal.(type))("1")>, false, <(literal.(type))("2")>, true, <(literal.(type))("3")>, false).selectWith(Predicates2.equal(), PrimitiveTuples.pair(<(literal.(type))("2")>, true)).toList();
        Verify.assertContains(PrimitiveTuples.pair(<(literal.(type))("2")>, true), result);
        Verify.assertNotContains(PrimitiveTuples.pair(<(literal.(type))("1")>, false), result);
        Verify.assertNotContains(PrimitiveTuples.pair(<(literal.(type))("3")>, false), result);
    }

    @Test
    public void selectWith_target()
    {
        HashBag\<<name>BooleanPair> result = this.newWith(<(literal.(type))("1")>, false, <(literal.(type))("2")>, true, <(literal.(type))("3")>, false).selectWith(Predicates2.notEqual(), PrimitiveTuples.pair(<(literal.(type))("2")>, true), HashBag.\<<name>BooleanPair>newBag());
        Assert.assertEquals(Bags.immutable.of(PrimitiveTuples.pair(<(literal.(type))("1")>, false), PrimitiveTuples.pair(<(literal.(type))("3")>, false)), result);
    }

    @Test
    public void reject()
    {
        MutableList\<<name>BooleanPair> result = this.newWith(<(literal.(type))("1")>, false, <(literal.(type))("2")>, true, <(literal.(type))("3")>, false).reject(Predicates.notEqual(PrimitiveTuples.pair(<(literal.(type))("2")>, true))).toList();
        Verify.assertContains(PrimitiveTuples.pair(<(literal.(type))("2")>, true), result);
        Verify.assertNotContains(PrimitiveTuples.pair(<(literal.(type))("1")>, false), result);
        Verify.assertNotContains(PrimitiveTuples.pair(<(literal.(type))("3")>, false), result);
    }

    @Test
    public void rejectWith()
    {
        MutableList\<<name>BooleanPair> result = this.newWith(<(literal.(type))("1")>, false, <(literal.(type))("2")>, true, <(literal.(type))("3")>, false).rejectWith(Predicates2.notEqual(), PrimitiveTuples.pair(<(literal.(type))("2")>, true)).toList();
        Verify.assertContains(PrimitiveTuples.pair(<(literal.(type))("2")>, true), result);
        Verify.assertNotContains(PrimitiveTuples.pair(<(literal.(type))("1")>, false), result);
        Verify.assertNotContains(PrimitiveTuples.pair(<(literal.(type))("3")>, false), result);
    }

    @Test
    public void rejectWith_target()
    {
        HashBag\<<name>BooleanPair> result = this.newWith(<(literal.(type))("1")>, false, <(literal.(type))("2")>, true, <(literal.(type))("3")>, false).rejectWith(Predicates2.equal(), PrimitiveTuples.pair(<(literal.(type))("2")>, true), HashBag.\<<name>BooleanPair>newBag());
        Assert.assertEquals(Bags.immutable.of(PrimitiveTuples.pair(<(literal.(type))("1")>, false), PrimitiveTuples.pair(<(literal.(type))("3")>, false)), result);
    }

    @Test
    public void selectInstancesOf()
    {
        RichIterable\<<name>BooleanPair> pairs = this.newWith(<(literal.(type))("1")>, false, <(literal.(type))("2")>, true, <(literal.(type))("3")>, false);
        Verify.assertIterableEmpty(pairs.selectInstancesOf(Integer.class));
        Verify.assertContainsAll(pairs.selectInstancesOf(<name>BooleanPair.class), PrimitiveTuples.pair(<(literal.(type))("1")>, false), PrimitiveTuples.pair(<(literal.(type))("3")>, false), PrimitiveTuples.pair(<(literal.(type))("2")>, true));
    }

    @Test
    public void collect()
    {
        RichIterable\<Integer> result1 = this.newWith(<(literal.(type))("1")>, false, <(literal.(type))("2")>, true, <(literal.(type))("3")>, false).collect(new Function\<<name>BooleanPair, Integer>()
        {
            public Integer valueOf(<name>BooleanPair object)
            {
                return (int) object.getOne();
            }
        });
        Assert.assertEquals(Bags.immutable.of(1, 2, 3), result1.toBag());
        RichIterable\<Boolean> result2 = this.newWith(<(literal.(type))("1")>, false, <(literal.(type))("2")>, true, <(literal.(type))("3")>, false).collect(new Function\<<name>BooleanPair, Boolean>()
        {
            public Boolean valueOf(<name>BooleanPair object)
            {
                return object.getTwo();
            }
        });
        Assert.assertEquals(Bags.immutable.of(false, true, false), result2.toBag());
    }

    @Test
    public void collectBoolean()
    {
        BooleanIterable result = this.newWith(<(literal.(type))("1")>, false, <(literal.(type))("2")>, true, <(literal.(type))("3")>, false).collectBoolean(new BooleanFunction\<<name>BooleanPair>()
        {
            public boolean booleanValueOf(<name>BooleanPair each)
            {
                return (each.getOne() % 2) == 0;
            }
        });
        Assert.assertEquals(BooleanHashBag.newBagWith(true, false, false), result.toBag());
    }

    @Test
    public void collectByte()
    {
        ByteIterable result = this.newWith(<(literal.(type))("1")>, false, <(literal.(type))("2")>, true, <(literal.(type))("3")>, false).collectByte(new ByteFunction\<<name>BooleanPair>()
        {
            public byte byteValueOf(<name>BooleanPair anObject)
            {
                return (byte) anObject.getOne();
            }
        });
        Assert.assertEquals(ByteHashBag.newBagWith((byte) 1, (byte) 2, (byte) 3), result.toBag());
    }

    @Test
    public void collectChar()
    {
        CharIterable result = this.newWith(<(literal.(type))("1")>, false, <(literal.(type))("2")>, true, <(literal.(type))("3")>, false).collectChar(new CharFunction\<<name>BooleanPair>()
        {
            public char charValueOf(<name>BooleanPair anObject)
            {
                return (char) anObject.getOne();
            }
        });
        Assert.assertEquals(CharHashBag.newBagWith((char) 1, (char) 2, (char) 3), result.toBag());
    }

    @Test
    public void collectDouble()
    {
        DoubleIterable result = this.newWith(<(literal.(type))("1")>, false, <(literal.(type))("2")>, true, <(literal.(type))("3")>, false).collectDouble(new DoubleFunction\<<name>BooleanPair>()
        {
            public double doubleValueOf(<name>BooleanPair anObject)
            {
                return (double) anObject.getOne();
            }
        });
        Assert.assertEquals(DoubleHashBag.newBagWith(1.0, 2.0, 3.0), result.toBag());
    }

    @Test
    public void collectFloat()
    {
        FloatIterable result = this.newWith(<(literal.(type))("1")>, false, <(literal.(type))("2")>, true, <(literal.(type))("3")>, false).collectFloat(new FloatFunction\<<name>BooleanPair>()
        {
            public float floatValueOf(<name>BooleanPair anObject)
            {
                return (float) anObject.getOne();
            }
        });
        Assert.assertEquals(FloatHashBag.newBagWith(1.0f, 2.0f, 3.0f), result.toBag());
    }

    @Test
    public void collectInt()
    {
        IntIterable result = this.newWith(<(literal.(type))("1")>, false, <(literal.(type))("2")>, true, <(literal.(type))("3")>, false).collectInt(new IntFunction\<<name>BooleanPair>()
        {
            public int intValueOf(<name>BooleanPair anObject)
            {
                return (int) anObject.getOne();
            }
        });
        Assert.assertEquals(IntHashBag.newBagWith(1, 2, 3), result.toBag());
    }

    @Test
    public void collectLong()
    {
        LongIterable result = this.newWith(<(literal.(type))("1")>, false, <(literal.(type))("2")>, true, <(literal.(type))("3")>, false).collectLong(new LongFunction\<<name>BooleanPair>()
        {
            public long longValueOf(<name>BooleanPair anObject)
            {
                return (long) anObject.getOne();
            }
        });
        Assert.assertEquals(LongHashBag.newBagWith(1L, 2L, 3L), result.toBag());
    }

    @Test
    public void collectShort()
    {
        ShortIterable result = this.newWith(<(literal.(type))("1")>, false, <(literal.(type))("2")>, true, <(literal.(type))("3")>, false).collectShort(new ShortFunction\<<name>BooleanPair>()
        {
            public short shortValueOf(<name>BooleanPair anObject)
            {
                return (short) anObject.getOne();
            }
        });
        Assert.assertEquals(ShortHashBag.newBagWith((short) 1, (short) 2, (short) 3), result.toBag());
    }

    @Test
    public void flatCollect()
    {
        RichIterable\<<name>BooleanPair> collection = this.newWith(<(literal.(type))("1")>, false, <(literal.(type))("2")>, true, <(literal.(type))("3")>, false);
        Function\<<name>BooleanPair, MutableList\<String>\> function =
                new Function\<<name>BooleanPair, MutableList\<String>\>()
                {
                    public MutableList\<String> valueOf(<name>BooleanPair object)
                    {
                        return FastList.newListWith(String.valueOf(object));
                    }
                };

        Verify.assertListsEqual(
                FastList.newListWith("<(toStringLiteral.(type))("1")>:false", "<(toStringLiteral.(type))("2")>:true", "<(toStringLiteral.(type))("3")>:false"),
                collection.flatCollect(function).toSortedList());

        Verify.assertSetsEqual(
                UnifiedSet.newSetWith("<(toStringLiteral.(type))("1")>:false", "<(toStringLiteral.(type))("2")>:true", "<(toStringLiteral.(type))("3")>:false"),
                collection.flatCollect(function, UnifiedSet.\<String>newSet()));
    }

    @Test
    public void detect()
    {
        Assert.assertEquals(PrimitiveTuples.pair(<(literal.(type))("2")>, true), this.newWith(<(literal.(type))("1")>, false, <(literal.(type))("2")>, true, <(literal.(type))("3")>, false).detect(Predicates.equal(PrimitiveTuples.pair(<(literal.(type))("2")>, true))));
        Assert.assertNull(this.newWith(<(literal.(type))("1")>, false, <(literal.(type))("2")>, true, <(literal.(type))("3")>, false).detect(Predicates.equal(PrimitiveTuples.pair(2, 4L))));
    }

    @Test(expected = NoSuchElementException.class)
    public void min_empty_throws()
    {
        this.newWith().min(Comparators.naturalOrder());
    }

    @Test(expected = NoSuchElementException.class)
    public void max_empty_throws()
    {
        this.newWith().max(Comparators.naturalOrder());
    }

    @Test
    public void min()
    {
        Assert.assertEquals(PrimitiveTuples.pair(<(literal.(type))("1")>, false), this.newWith(<(literal.(type))("1")>, false, <(literal.(type))("2")>, true, <(literal.(type))("3")>, false).min(Comparators.naturalOrder()));
    }

    @Test
    public void max()
    {
        Assert.assertEquals(PrimitiveTuples.pair(<(literal.(type))("3")>, false), this.newWith(<(literal.(type))("1")>, false, <(literal.(type))("2")>, true, <(literal.(type))("3")>, false).max(Comparators.naturalOrder()));
    }

    @Test
    public void min_without_comparator()
    {
        Assert.assertEquals(PrimitiveTuples.pair(<(literal.(type))("1")>, false), this.newWith(<(literal.(type))("1")>, false, <(literal.(type))("2")>, true, <(literal.(type))("3")>, false).min(Comparators.naturalOrder()));
    }

    @Test
    public void max_without_comparator()
    {
        Assert.assertEquals(PrimitiveTuples.pair(<(literal.(type))("3")>, false), this.newWith(<(literal.(type))("1")>, false, <(literal.(type))("2")>, true, <(literal.(type))("3")>, false).max(Comparators.naturalOrder()));
    }

    @Test
    public void minBy()
    {
        Assert.assertEquals(PrimitiveTuples.pair(<(literal.(type))("2")>, true), this.newWith(<(literal.(type))("1")>, false, <(literal.(type))("2")>, true, <(literal.(type))("3")>, false).minBy(new Function\<<name>BooleanPair, Integer>()
        {
            public Integer valueOf(<name>BooleanPair object)
            {
                return (int) object.getOne() & 1;
            }
        }));
    }

    @Test
    public void maxBy()
    {
        Assert.assertEquals(PrimitiveTuples.pair(<(literal.(type))("1")>, false), this.newWith(<(literal.(type))("1")>, false, <(literal.(type))("2")>, true, <(literal.(type))("4")>, false).maxBy(new Function\<<name>BooleanPair, Integer>()
        {
            public Integer valueOf(<name>BooleanPair object)
            {
                return (int) object.getOne() & 1;
            }
        }));
    }

    @Test
    public void detectWith()
    {
        Assert.assertEquals(PrimitiveTuples.pair(<(literal.(type))("2")>, true), this.newWith(<(literal.(type))("1")>, false, <(literal.(type))("2")>, true, <(literal.(type))("3")>, false).detectWith(Predicates2.equal(), PrimitiveTuples.pair(<(literal.(type))("2")>, true)));
        Assert.assertNull(this.newWith(<(literal.(type))("1")>, false, <(literal.(type))("2")>, true, <(literal.(type))("3")>, false).detectWith(Predicates2.equal(), PrimitiveTuples.pair(<(literal.(type))("2")>, false)));
    }

    @Test
    public void detectIfNone()
    {
        Function0\<<name>BooleanPair> function = Functions0.value(PrimitiveTuples.pair(<(literal.(type))("5")>, true));
        Assert.assertEquals(PrimitiveTuples.pair(<(literal.(type))("2")>, true), this.newWith(<(literal.(type))("1")>, false, <(literal.(type))("2")>, true, <(literal.(type))("3")>, false).detectIfNone(Predicates.equal(PrimitiveTuples.pair(<(literal.(type))("2")>, true)), function));
        Assert.assertEquals(PrimitiveTuples.pair(<(literal.(type))("5")>, true), this.newWith(<(literal.(type))("1")>, false, <(literal.(type))("2")>, true, <(literal.(type))("3")>, false).detectIfNone(Predicates.equal(PrimitiveTuples.pair(<(literal.(type))("2")>, false)), function));
    }

    @Test
    public void detectWithIfNoneBlock()
    {
        Function0\<<name>BooleanPair> function = Functions0.value(PrimitiveTuples.pair(<(literal.(type))("5")>, true));
        Assert.assertEquals(PrimitiveTuples.pair(<(literal.(type))("2")>, true), this.newWith(<(literal.(type))("1")>, false, <(literal.(type))("2")>, true, <(literal.(type))("3")>, false).detectWithIfNone(Predicates2.equal(),
                PrimitiveTuples.pair(<(literal.(type))("2")>, true),
                function));
        Assert.assertEquals(PrimitiveTuples.pair(<(literal.(type))("5")>, true), this.newWith(<(literal.(type))("1")>, false, <(literal.(type))("2")>, true, <(literal.(type))("3")>, false).detectWithIfNone(Predicates2.equal(),
                PrimitiveTuples.pair(<(literal.(type))("2")>, false),
                function));
    }

    @Test
    public void allSatisfy()
    {
        Assert.assertTrue(this.newWith(<(literal.(type))("1")>, false, <(literal.(type))("2")>, true, <(literal.(type))("3")>, false).allSatisfy(Predicates.instanceOf(<name>BooleanPair.class)));
        Assert.assertFalse(this.newWith(<(literal.(type))("1")>, false, <(literal.(type))("2")>, true, <(literal.(type))("3")>, false).allSatisfy(Predicates.equal(PrimitiveTuples.pair(<(literal.(type))("2")>, true))));
    }

    @Test
    public void allSatisfyWith()
    {
        Assert.assertTrue(this.newWith(<(literal.(type))("1")>, false, <(literal.(type))("2")>, true, <(literal.(type))("3")>, false).allSatisfyWith(Predicates2.instanceOf(), <name>BooleanPair.class));
        Assert.assertFalse(this.newWith(<(literal.(type))("1")>, false, <(literal.(type))("2")>, true, <(literal.(type))("3")>, false).allSatisfyWith(Predicates2.equal(), PrimitiveTuples.pair(<(literal.(type))("2")>, true)));
    }

    @Test
    public void noneSatisfy()
    {
        Assert.assertTrue(this.newWith(<(literal.(type))("1")>, false, <(literal.(type))("2")>, true, <(literal.(type))("3")>, false).noneSatisfy(Predicates.instanceOf(Boolean.class)));
        Assert.assertFalse(this.newWith(<(literal.(type))("1")>, false, <(literal.(type))("2")>, true, <(literal.(type))("3")>, false).noneSatisfy(Predicates.equal(PrimitiveTuples.pair(<(literal.(type))("2")>, true))));
    }

    @Test
    public void noneSatisfyWith()
    {
        Assert.assertTrue(this.newWith(<(literal.(type))("1")>, false, <(literal.(type))("2")>, true, <(literal.(type))("3")>, false).noneSatisfyWith(Predicates2.instanceOf(), Boolean.class));
        Assert.assertFalse(this.newWith(<(literal.(type))("1")>, false, <(literal.(type))("2")>, true, <(literal.(type))("3")>, false).noneSatisfyWith(Predicates2.equal(), PrimitiveTuples.pair(<(literal.(type))("2")>, true)));
    }

    @Test
    public void anySatisfy()
    {
        Assert.assertTrue(this.newWith(<(literal.(type))("1")>, false, <(literal.(type))("2")>, true, <(literal.(type))("3")>, false).anySatisfy(Predicates.equal(PrimitiveTuples.pair(<(literal.(type))("2")>, true))));
        Assert.assertFalse(this.newWith(<(literal.(type))("1")>, false, <(literal.(type))("2")>, true, <(literal.(type))("3")>, false).anySatisfy(Predicates.equal(PrimitiveTuples.pair(2, 5L))));
    }

    @Test
    public void anySatisfyWith()
    {
        Assert.assertTrue(this.newWith(<(literal.(type))("1")>, false, <(literal.(type))("2")>, true, <(literal.(type))("3")>, false).anySatisfyWith(Predicates2.equal(), PrimitiveTuples.pair(<(literal.(type))("2")>, true)));
        Assert.assertFalse(this.newWith(<(literal.(type))("1")>, false, <(literal.(type))("2")>, true, <(literal.(type))("3")>, false).anySatisfyWith(Predicates2.equal(), PrimitiveTuples.pair(2, 5L)));
    }

    @Test
    public void count()
    {
        Assert.assertEquals(0, this.newWith(<(literal.(type))("1")>, false, <(literal.(type))("2")>, true, <(literal.(type))("3")>, false).count(Predicates.instanceOf(Boolean.class)));
        Assert.assertEquals(3, this.newWith(<(literal.(type))("1")>, false, <(literal.(type))("2")>, true, <(literal.(type))("3")>, false).count(Predicates.instanceOf(<name>BooleanPair.class)));
        Assert.assertEquals(1, this.newWith(<(literal.(type))("1")>, false, <(literal.(type))("2")>, true, <(literal.(type))("3")>, false).count(Predicates.equal(PrimitiveTuples.pair(<(literal.(type))("2")>, true))));
    }

    @Test
    public void countWith()
    {
        Assert.assertEquals(0, this.newWith(<(literal.(type))("1")>, false, <(literal.(type))("2")>, true, <(literal.(type))("3")>, false).countWith(Predicates2.instanceOf(), Boolean.class));
        Assert.assertEquals(3, this.newWith(<(literal.(type))("1")>, false, <(literal.(type))("2")>, true, <(literal.(type))("3")>, false).countWith(Predicates2.instanceOf(), <name>BooleanPair.class));
        Assert.assertEquals(1, this.newWith(<(literal.(type))("1")>, false, <(literal.(type))("2")>, true, <(literal.(type))("3")>, false).countWith(Predicates2.equal(), PrimitiveTuples.pair(<(literal.(type))("2")>, true)));
    }

    @Test
    public void collectIf()
    {
        Verify.assertContainsAll(
                this.newWith(<(literal.(type))("1")>, false, <(literal.(type))("2")>, true, <(literal.(type))("3")>, false).collectIf(
                        Predicates.instanceOf(<name>BooleanPair.class),
                        Functions.getToString()),
                "<(toStringLiteral.(type))("1")>:false", "<(toStringLiteral.(type))("2")>:true", "<(toStringLiteral.(type))("3")>:false");
        Verify.assertContainsAll(
                this.newWith(<(literal.(type))("1")>, false, <(literal.(type))("2")>, true, <(literal.(type))("3")>, false).collectIf(
                        Predicates.instanceOf(<name>BooleanPair.class),
                        Functions.getToString(),
                        UnifiedSet.\<String>newSet()),
                "<(toStringLiteral.(type))("1")>:false", "<(toStringLiteral.(type))("2")>:true", "<(toStringLiteral.(type))("3")>:false");
    }

    @Test
    public void collectWith()
    {
        Assert.assertEquals(
                Bags.mutable.of("<(toStringLiteral.(type))("3")>:false-", "<(toStringLiteral.(type))("2")>:true-", "<(toStringLiteral.(type))("1")>:false-"),

                this.newWith(<(literal.(type))("1")>, false, <(literal.(type))("2")>, true, <(literal.(type))("3")>, false).collectWith(new Function2\<<name>BooleanPair, String, String>()
                {
                    public String value(<name>BooleanPair argument1, String argument2)
                    {
                        return argument1 + argument2;
                    }
                }, "-").toBag());
    }

    @Test
    public void collectWith_target()
    {
        Assert.assertEquals(
                Bags.mutable.of("<(toStringLiteral.(type))("1")>:false-", "<(toStringLiteral.(type))("2")>:true-", "<(toStringLiteral.(type))("3")>:false-"),
                this.newWith(<(literal.(type))("1")>, false, <(literal.(type))("2")>, true, <(literal.(type))("3")>, false).collectWith(new Function2\<<name>BooleanPair, String, String>()
                {
                    public String value(<name>BooleanPair argument1, String argument2)
                    {
                        return argument1 + argument2;
                    }
                }, "-", HashBag.\<String>newBag()));
    }

    @Test
    public void getFirst()
    {
        <name>BooleanPair first = this.newWith(<(literal.(type))("1")>, false, <(literal.(type))("2")>, true, <(literal.(type))("3")>, false).getFirst();
        Assert.assertTrue(PrimitiveTuples.pair(<(literal.(type))("1")>, false).equals(first)
                || PrimitiveTuples.pair(<(literal.(type))("2")>, true).equals(first)
                || PrimitiveTuples.pair(<(literal.(type))("3")>, false).equals(first));
        Assert.assertEquals(PrimitiveTuples.pair(<(literal.(type))("1")>, false), this.newWith(<(literal.(type))("1")>, false).getFirst());
    }

    @Test
    public void getLast()
    {
        <name>BooleanPair last = this.newWith(<(literal.(type))("1")>, false, <(literal.(type))("2")>, true, <(literal.(type))("3")>, false).getLast();
        Assert.assertTrue(PrimitiveTuples.pair(<(literal.(type))("1")>, false).equals(last)
                || PrimitiveTuples.pair(<(literal.(type))("2")>, true).equals(last)
                || PrimitiveTuples.pair(<(literal.(type))("3")>, false).equals(last));
        Assert.assertEquals(PrimitiveTuples.pair(<(literal.(type))("1")>, false), this.newWith(<(literal.(type))("1")>, false).getLast());
    }

    @Test
    public void isEmpty()
    {
        Verify.assertIterableEmpty(this.newWith());
        Verify.assertIterableNotEmpty(this.newWith(<(literal.(type))("1")>, false));
        Assert.assertTrue(this.newWith(<(literal.(type))("1")>, false).notEmpty());
    }

    @Test
    public void iterator()
    {
        RichIterable\<<name>BooleanPair> objects = this.newWith(<(literal.(type))("1")>, false, <(literal.(type))("0")>, true, <(literal.(type))("3")>, false);
        MutableBag\<<name>BooleanPair> actual = Bags.mutable.of();
        Iterator\<<name>BooleanPair> iterator = objects.iterator();
        for (int i = objects.size(); i-- > 0; )
        {
            Assert.assertTrue(iterator.hasNext());
            actual.add(iterator.next());
        }
        Assert.assertFalse(iterator.hasNext());
        Assert.assertEquals(objects.toBag(), actual);
    }

    @Test(expected = NoSuchElementException.class)
    public void iterator_next_throws()
    {
        RichIterable\<<name>BooleanPair> objects = this.newWith(<(literal.(type))("1")>, false, <(literal.(type))("2")>, true, <(literal.(type))("3")>, false);
        Iterator\<<name>BooleanPair> iterator = objects.iterator();
        for (int i = objects.size(); i-- > 0; )
        {
            Assert.assertTrue(iterator.hasNext());
            iterator.next();
        }
        Assert.assertFalse(iterator.hasNext());
        iterator.next();
    }

    @Test(expected = UnsupportedOperationException.class)
    public void iterator_remove_throws()
    {
        RichIterable\<<name>BooleanPair> objects = this.newWith(<(literal.(type))("1")>, false, <(literal.(type))("2")>, true, <(literal.(type))("3")>, false);
        Iterator\<<name>BooleanPair> iterator = objects.iterator();
        iterator.remove();
    }

    @Test
    public void injectInto()
    {
        RichIterable\<<name>BooleanPair> objects = this.newWith(<(literal.(type))("1")>, false, <(literal.(type))("2")>, true, <(literal.(type))("3")>, false);
        Long result = objects.injectInto(1L, new Function2\<Long, <name>BooleanPair, Long>()
        {
            public Long value(Long argument1, <name>BooleanPair argument2)
            {
                return (long) (argument1 + argument2.getOne() + (argument2.getTwo() ? 0 : 1));
            }
        });
        Assert.assertEquals(Long.valueOf(9), result);
    }

    @Test
    public void injectIntoInt()
    {
        RichIterable\<<name>BooleanPair> objects = this.newWith(<(literal.(type))("1")>, false, <(literal.(type))("2")>, true, <(literal.(type))("3")>, false);
        int result = objects.injectInto(1, new IntObjectToIntFunction\<<name>BooleanPair>()
        {
            public int intValueOf(int intParameter, <name>BooleanPair argument2)
            {
                return (int) (intParameter + argument2.getOne() + (argument2.getTwo() ? 0 : 1));
            }
        });
        Assert.assertEquals(9, result);
    }

    @Test
    public void injectIntoLong()
    {
        RichIterable\<<name>BooleanPair> objects = this.newWith(<(literal.(type))("1")>, false, <(literal.(type))("2")>, true, <(literal.(type))("3")>, false);
        long result = objects.injectInto(1L, new LongObjectToLongFunction\<<name>BooleanPair>()
        {
            public long longValueOf(long parameter, <name>BooleanPair argument2)
            {
                return (long) (parameter + argument2.getOne() + (argument2.getTwo() ? 0 : 1));
            }
        });
        Assert.assertEquals(9, result);
    }

    @Test
    public void injectIntoDouble()
    {
        RichIterable\<<name>BooleanPair> objects = this.newWith(<(literal.(type))("1")>, false, <(literal.(type))("2")>, true, <(literal.(type))("3")>, false);
        double result = objects.injectInto(1.0, new DoubleObjectToDoubleFunction\<<name>BooleanPair>()
        {
            public double doubleValueOf(double parameter, <name>BooleanPair argument2)
            {
                return (double) (parameter + argument2.getOne() + (argument2.getTwo() ? 0 : 1));
            }
        });
        Assert.assertEquals(9.0, result, 0.0);
    }

    @Test
    public void injectIntoFloat()
    {
        RichIterable\<<name>BooleanPair> objects = this.newWith(<(literal.(type))("1")>, false, <(literal.(type))("2")>, true, <(literal.(type))("3")>, false);
        float result = objects.injectInto(1.0f, new FloatObjectToFloatFunction\<<name>BooleanPair>()
        {
            public float floatValueOf(float parameter, <name>BooleanPair argument2)
            {
                return (float) (parameter + argument2.getOne() + (argument2.getTwo() ? 0 : 1));
            }
        });
        Assert.assertEquals(9.0, result, 0.0);
    }

    @Test
    public void sumFloat()
    {
        RichIterable\<<name>BooleanPair> objects = this.newWith(<(literal.(type))("1")>, false, <(literal.(type))("2")>, true, <(literal.(type))("3")>, false);
        double actual = objects.sumOfFloat(new FloatFunction\<<name>BooleanPair>()
        {
            public float floatValueOf(<name>BooleanPair each)
            {
                return (float) (each.getOne() + (each.getTwo() ? 0 : 1));
            }
        });
        Assert.assertEquals(8.0, actual, 0.0);
    }

    @Test
    public void sumDouble()
    {
        RichIterable\<<name>BooleanPair> objects = this.newWith(<(literal.(type))("1")>, false, <(literal.(type))("2")>, true, <(literal.(type))("3")>, false);
        double actual = objects.sumOfDouble(new DoubleFunction\<<name>BooleanPair>()
        {
            public double doubleValueOf(<name>BooleanPair each)
            {
                return (double) (each.getOne() + (each.getTwo() ? 0 : 1));
            }
        });
        Assert.assertEquals(8.0, actual, 0.0);
    }

    @Test
    public void sumInteger()
    {
        RichIterable\<<name>BooleanPair> objects = this.newWith(<(literal.(type))("1")>, false, <(literal.(type))("2")>, true, <(literal.(type))("3")>, false);
        long actual = objects.sumOfInt(new IntFunction\<<name>BooleanPair>()
        {
            public int intValueOf(<name>BooleanPair each)
            {
                return (int) (each.getOne() + (each.getTwo() ? 0 : 1));
            }
        });
        Assert.assertEquals(8, actual);
    }

    @Test
    public void sumLong()
    {
        RichIterable\<<name>BooleanPair> objects = this.newWith(<(literal.(type))("1")>, false, <(literal.(type))("2")>, true, <(literal.(type))("3")>, false);
        long actual = objects.sumOfLong(new LongFunction\<<name>BooleanPair>()
        {
            public long longValueOf(<name>BooleanPair each)
            {
                return (long) (each.getOne() + (each.getTwo() ? 0 : 1));
            }
        });
        Assert.assertEquals(8, actual);
    }

    @Test
    public void toArray()
    {
        RichIterable\<<name>BooleanPair> objects = this.newWith(<(literal.(type))("1")>, false, <(literal.(type))("2")>, true, <(literal.(type))("3")>, false);
        Object[] array = objects.toArray();
        Verify.assertSize(3, array);
        <name>BooleanPair[] array2 = objects.toArray(new <name>BooleanPair[3]);
        Verify.assertSize(3, array2);
    }

    @Test
    public void partition()
    {
        PartitionIterable\<<name>BooleanPair> result = this.newWith(<(literal.(type))("1")>, false, <(literal.(type))("2")>, true, <(literal.(type))("3")>, false).partition(Predicates.equal(PrimitiveTuples.pair(<(literal.(type))("2")>, true)));
        Verify.assertContains(PrimitiveTuples.pair(<(literal.(type))("2")>, true), result.getSelected().toList());
        Verify.assertIterableSize(1, result.getSelected());
        Verify.assertContains(PrimitiveTuples.pair(<(literal.(type))("1")>, false), result.getRejected().toList());
        Verify.assertContains(PrimitiveTuples.pair(<(literal.(type))("3")>, false), result.getRejected().toList());
        Verify.assertIterableSize(2, result.getRejected());
    }

    @Test
    public void partitionWith()
    {
        PartitionIterable\<<name>BooleanPair> result = this.newWith(<(literal.(type))("1")>, false, <(literal.(type))("2")>, true, <(literal.(type))("3")>, false).partitionWith(Predicates2.equal(), PrimitiveTuples.pair(<(literal.(type))("2")>, true));
        Verify.assertContains(PrimitiveTuples.pair(<(literal.(type))("2")>, true), result.getSelected().toList());
        Verify.assertIterableSize(1, result.getSelected());
        Verify.assertContains(PrimitiveTuples.pair(<(literal.(type))("1")>, false), result.getRejected().toList());
        Verify.assertContains(PrimitiveTuples.pair(<(literal.(type))("3")>, false), result.getRejected().toList());
        Verify.assertIterableSize(2, result.getRejected());
    }

    @Test
    public void toList()
    {
        MutableList\<<name>BooleanPair> list = this.newWith(<(literal.(type))("1")>, false, <(literal.(type))("2")>, true, <(literal.(type))("3")>, false).toList();
        Verify.assertContainsAll(list, PrimitiveTuples.pair(<(literal.(type))("1")>, false), PrimitiveTuples.pair(<(literal.(type))("2")>, true), PrimitiveTuples.pair(<(literal.(type))("3")>, false));
    }

    @Test
    public void toBag()
    {
        MutableBag\<<name>BooleanPair> bag = this.newWith(<(literal.(type))("1")>, false, <(literal.(type))("2")>, true, <(literal.(type))("3")>, false).toBag();
        Verify.assertContainsAll(bag, PrimitiveTuples.pair(<(literal.(type))("1")>, false), PrimitiveTuples.pair(<(literal.(type))("2")>, true), PrimitiveTuples.pair(<(literal.(type))("3")>, false));
    }

    @Test
    public void toSortedList_natural_ordering()
    {
        RichIterable\<<name>BooleanPair> pairs = this.newWith(<(literal.(type))("2")>, true, <(literal.(type))("1")>, false, <(literal.(type))("3")>, false);
        MutableList\<<name>BooleanPair> list = pairs.toSortedList();
        Assert.assertEquals(Lists.mutable.of(PrimitiveTuples.pair(<(literal.(type))("1")>, false), PrimitiveTuples.pair(<(literal.(type))("2")>, true), PrimitiveTuples.pair(<(literal.(type))("3")>, false)), list);
    }

    @Test
    public void toSortedList_with_comparator()
    {
        RichIterable\<<name>BooleanPair> pairs = this.newWith(<(literal.(type))("2")>, true, <(literal.(type))("1")>, false, <(literal.(type))("3")>, false);
        MutableList\<<name>BooleanPair> list = pairs.toSortedList(Comparators.reverseNaturalOrder());
        Assert.assertEquals(Lists.mutable.of(PrimitiveTuples.pair(<(literal.(type))("3")>, false), PrimitiveTuples.pair(<(literal.(type))("2")>, true), PrimitiveTuples.pair(<(literal.(type))("1")>, false)), list);
    }

    @Test
    public void toSortedListBy()
    {
        RichIterable\<<name>BooleanPair> pairs = this.newWith(<(literal.(type))("2")>, true, <(literal.(type))("1")>, false, <(literal.(type))("3")>, false);
        MutableList\<<name>BooleanPair> list = pairs.toSortedListBy(Functions.getToString());
        Assert.assertEquals(Lists.mutable.of(PrimitiveTuples.pair(<(literal.(type))("1")>, false), PrimitiveTuples.pair(<(literal.(type))("2")>, true), PrimitiveTuples.pair(<(literal.(type))("3")>, false)), list);
    }

    @Test
    public void toSortedSet_natural_ordering()
    {
        RichIterable\<<name>BooleanPair> pairs = this.newWith(<(literal.(type))("2")>, true, <(literal.(type))("1")>, false, <(literal.(type))("3")>, false);
        MutableSortedSet\<<name>BooleanPair> set = pairs.toSortedSet();
        Verify.assertSortedSetsEqual(TreeSortedSet.newSetWith(PrimitiveTuples.pair(<(literal.(type))("1")>, false), PrimitiveTuples.pair(<(literal.(type))("2")>, true), PrimitiveTuples.pair(<(literal.(type))("3")>, false)), set);
    }

    @Test
    public void toSortedSet_with_comparator()
    {
        RichIterable\<<name>BooleanPair> pairs = this.newWith(<(literal.(type))("2")>, true, <(literal.(type))("1")>, false, <(literal.(type))("3")>, false);
        MutableSortedSet\<<name>BooleanPair> set = pairs.toSortedSet(Comparators.reverseNaturalOrder());
        Verify.assertSortedSetsEqual(TreeSortedSet.newSetWith(Comparators.reverseNaturalOrder(),
                PrimitiveTuples.pair(<(literal.(type))("3")>, false),
                PrimitiveTuples.pair(<(literal.(type))("2")>, true),
                PrimitiveTuples.pair(<(literal.(type))("1")>, false)),
                set);
    }

    @Test
    public void toSortedSetBy()
    {
        RichIterable\<<name>BooleanPair> pairs = this.newWith(<(literal.(type))("2")>, true, <(literal.(type))("1")>, false, <(literal.(type))("3")>, false);
        MutableSortedSet\<<name>BooleanPair> set = pairs.toSortedSetBy(Functions.getToString());
        Verify.assertSortedSetsEqual(TreeSortedSet.newSetWith(PrimitiveTuples.pair(<(literal.(type))("1")>, false), PrimitiveTuples.pair(<(literal.(type))("2")>, true), PrimitiveTuples.pair(<(literal.(type))("3")>, false)), set);
    }

    @Test
    public void toSet()
    {
        RichIterable\<<name>BooleanPair> pairs = this.newWith(<(literal.(type))("1")>, false, <(literal.(type))("2")>, true, <(literal.(type))("3")>, false);
        MutableSet\<<name>BooleanPair> set = pairs.toSet();
        Verify.assertContainsAll(set, PrimitiveTuples.pair(<(literal.(type))("1")>, false), PrimitiveTuples.pair(<(literal.(type))("2")>, true), PrimitiveTuples.pair(<(literal.(type))("3")>, false));
    }

    @Test
    public void toMap()
    {
        RichIterable\<<name>BooleanPair> pairs = this.newWith(<(literal.(type))("1")>, false, <(literal.(type))("2")>, true, <(literal.(type))("3")>, false);
        MutableMap\<String, String> map =
                pairs.toMap(Functions.getToString(), Functions.getToString());
        Assert.assertEquals(UnifiedMap.newWithKeysValues("<(toStringLiteral.(type))("1")>:false", "<(toStringLiteral.(type))("1")>:false", "<(toStringLiteral.(type))("2")>:true", "<(toStringLiteral.(type))("2")>:true", "<(toStringLiteral.(type))("3")>:false", "<(toStringLiteral.(type))("3")>:false"), map);
    }

    @Test
    public void toSortedMap()
    {
        RichIterable\<<name>BooleanPair> pairs = this.newWith(<(literal.(type))("1")>, false, <(literal.(type))("2")>, true, <(literal.(type))("3")>, false);
        MutableSortedMap\<String, String> map =
                pairs.toSortedMap(Functions.getToString(), Functions.getToString());
        Assert.assertEquals(TreeSortedMap.newMapWith("<(toStringLiteral.(type))("1")>:false", "<(toStringLiteral.(type))("1")>:false", "<(toStringLiteral.(type))("2")>:true", "<(toStringLiteral.(type))("2")>:true", "<(toStringLiteral.(type))("3")>:false", "<(toStringLiteral.(type))("3")>:false"), map);
    }

    @Test
    public void toSortedMap_with_comparator()
    {
        RichIterable\<<name>BooleanPair> pairs = this.newWith(<(literal.(type))("1")>, false, <(literal.(type))("2")>, true, <(literal.(type))("3")>, false);
        MutableSortedMap\<String, String> map =
                pairs.toSortedMap(Comparators.reverseNaturalOrder(), Functions.getToString(), Functions.getToString());
        Assert.assertEquals(TreeSortedMap.newMapWith(Comparators.reverseNaturalOrder(), "<(toStringLiteral.(type))("1")>:false", "<(toStringLiteral.(type))("1")>:false", "<(toStringLiteral.(type))("2")>:true", "<(toStringLiteral.(type))("2")>:true", "<(toStringLiteral.(type))("3")>:false", "<(toStringLiteral.(type))("3")>:false"), map);
    }

    @Test
    public void testToString()
    {
        RichIterable\<<name>BooleanPair> collection = this.newWith(<(literal.(type))("1")>, false, <(literal.(type))("2")>, true);
        Assert.assertTrue("[<(toStringLiteral.(type))("1")>:false, <(toStringLiteral.(type))("2")>:true]".equals(collection.toString()) ||
                "[<(toStringLiteral.(type))("2")>:true, <(toStringLiteral.(type))("1")>:false]".equals(collection.toString()));
    }

    @Test
    public void makeString()
    {
        RichIterable\<<name>BooleanPair> collection = this.newWith(<(literal.(type))("1")>, false, <(literal.(type))("2")>, true, <(literal.(type))("3")>, false);
        Assert.assertEquals(collection.toString(), '[' + collection.makeString() + ']');
    }

    @Test
    public void makeStringWithSeparator()
    {
        RichIterable\<<name>BooleanPair> collection = this.newWith(<(literal.(type))("1")>, false, <(literal.(type))("2")>, true, <(literal.(type))("3")>, false);
        Assert.assertEquals(collection.toString(), '[' + collection.makeString(", ") + ']');
    }

    @Test
    public void makeStringWithSeparatorAndStartAndEnd()
    {
        RichIterable\<<name>BooleanPair> collection = this.newWith(<(literal.(type))("1")>, false, <(literal.(type))("2")>, true, <(literal.(type))("3")>, false);
        Assert.assertEquals(collection.toString(), collection.makeString("[", ", ", "]"));
    }

    @Test
    public void appendString()
    {
        RichIterable\<<name>BooleanPair> collection = this.newWith(<(literal.(type))("1")>, false, <(literal.(type))("2")>, true, <(literal.(type))("3")>, false);
        Appendable builder = new StringBuilder();
        collection.appendString(builder);
        Assert.assertEquals(collection.toString(), '[' + builder.toString() + ']');
    }

    @Test
    public void appendStringWithSeparator()
    {
        RichIterable\<<name>BooleanPair> collection = this.newWith(<(literal.(type))("1")>, false, <(literal.(type))("2")>, true, <(literal.(type))("3")>, false);
        Appendable builder = new StringBuilder();
        collection.appendString(builder, ", ");
        Assert.assertEquals(collection.toString(), '[' + builder.toString() + ']');
    }

    @Test
    public void appendStringWithSeparatorAndStartAndEnd()
    {
        RichIterable\<<name>BooleanPair> collection = this.newWith(<(literal.(type))("1")>, false, <(literal.(type))("2")>, true, <(literal.(type))("3")>, false);
        Appendable builder = new StringBuilder();
        collection.appendString(builder, "[", ", ", "]");
        Assert.assertEquals(collection.toString(), builder.toString());
    }

    @Test
    public void groupBy()
    {
        RichIterable\<<name>BooleanPair> collection = this.newWith(<(literal.(type))("1")>, false, <(literal.(type))("2")>, true, <(literal.(type))("3")>, false);
        Function\<<name>BooleanPair, Boolean> function = new Function\<<name>BooleanPair, Boolean>()
        {
            public Boolean valueOf(<name>BooleanPair object)
            {
                return PrimitiveTuples.pair(<(literal.(type))("1")>, false).equals(object);
            }
        };

        Multimap\<Boolean, <name>BooleanPair> multimap = collection.groupBy(function);
        Assert.assertEquals(3, multimap.size());
        Assert.assertTrue(multimap.containsKeyAndValue(Boolean.TRUE, PrimitiveTuples.pair(<(literal.(type))("1")>, false)));
        Assert.assertTrue(multimap.containsKeyAndValue(Boolean.FALSE, PrimitiveTuples.pair(<(literal.(type))("2")>, true)));
        Assert.assertTrue(multimap.containsKeyAndValue(Boolean.FALSE, PrimitiveTuples.pair(<(literal.(type))("3")>, false)));
    }

    @Test
    public void groupByEach()
    {
        RichIterable\<<name>BooleanPair> collection = this.newWith(<(literal.(type))("1")>, false, <(literal.(type))("2")>, true, <(literal.(type))("3")>, false);
        Function\<<name>BooleanPair, MutableList\<Boolean>\> function = new Function\<<name>BooleanPair, MutableList\<Boolean>\>()
        {
            public MutableList\<Boolean> valueOf(<name>BooleanPair object)
            {
                return Lists.mutable.of(PrimitiveTuples.pair(<(literal.(type))("1")>, false).equals(object));
            }
        };

        Multimap\<Boolean, <name>BooleanPair> multimap = collection.groupByEach(function);
        Assert.assertEquals(3, multimap.size());
        Assert.assertTrue(multimap.containsKeyAndValue(Boolean.TRUE, PrimitiveTuples.pair(<(literal.(type))("1")>, false)));
        Assert.assertTrue(multimap.containsKeyAndValue(Boolean.FALSE, PrimitiveTuples.pair(<(literal.(type))("2")>, true)));
        Assert.assertTrue(multimap.containsKeyAndValue(Boolean.FALSE, PrimitiveTuples.pair(<(literal.(type))("3")>, false)));
    }

    @Test
    public void zip()
    {
        RichIterable\<<name>BooleanPair> collection = this.newWith(<(literal.(type))("1")>, false, <(literal.(type))("2")>, true);
        RichIterable\<Pair\<<name>BooleanPair, Integer>\> result = collection.zip(Interval.oneTo(5));

        Assert.assertTrue(Bags.mutable.of(Tuples.pair(PrimitiveTuples.pair(<(literal.(type))("1")>, false), 1), Tuples.pair(PrimitiveTuples.pair(<(literal.(type))("2")>, true), 2)).equals(result.toBag()) ||
                Bags.mutable.of(Tuples.pair(PrimitiveTuples.pair(<(literal.(type))("2")>, true), 1), Tuples.pair(PrimitiveTuples.pair(<(literal.(type))("1")>, false), 2)).equals(result.toBag()));
    }

    @Test
    public void zipWithIndex()
    {
        RichIterable\<<name>BooleanPair> collection = this.newWith(<(literal.(type))("1")>, false, <(literal.(type))("2")>, true);
        RichIterable\<Pair\<<name>BooleanPair, Integer>\> result = collection.zipWithIndex();
        Assert.assertTrue(Bags.mutable.of(Tuples.pair(PrimitiveTuples.pair(<(literal.(type))("1")>, false), 0), Tuples.pair(PrimitiveTuples.pair(<(literal.(type))("2")>, true), 1)).equals(result.toBag()) ||
                Bags.mutable.of(Tuples.pair(PrimitiveTuples.pair(<(literal.(type))("2")>, true), 0), Tuples.pair(PrimitiveTuples.pair(<(literal.(type))("1")>, false), 1)).equals(result.toBag()));
    }

    @Test
    public void chunk()
    {
        RichIterable\<<name>BooleanPair> collection = this.newWith(<(literal.(type))("1")>, false, <(literal.(type))("2")>, true, <(literal.(type))("3")>, false);
        Assert.assertEquals(Bags.immutable.of(FastList.newListWith(PrimitiveTuples.pair(<(literal.(type))("1")>, false)),
                FastList.newListWith(PrimitiveTuples.pair(<(literal.(type))("2")>, true)),
                FastList.newListWith(PrimitiveTuples.pair(<(literal.(type))("3")>, false))),
                collection.chunk(1).toBag());
    }

    @Test(expected = IllegalArgumentException.class)
    public void chunk_zero_throws()
    {
        RichIterable\<<name>BooleanPair> collection = this.newWith(<(literal.(type))("1")>, false, <(literal.(type))("2")>, true, <(literal.(type))("3")>, false);
        collection.chunk(0);
    }

    @Test
    public void chunk_large_size()
    {
        RichIterable\<<name>BooleanPair> collection = this.newWith(<(literal.(type))("1")>, false, <(literal.(type))("2")>, true, <(literal.(type))("3")>, false);
        Verify.assertIterableSize(3, collection.chunk(10).getFirst());
    }

    @Test
    public void empty()
    {
        Verify.assertIterableEmpty(this.newWith());
        Assert.assertTrue(this.newWith().isEmpty());
        Assert.assertFalse(this.newWith().notEmpty());
    }

    @Test
    public void notEmpty()
    {
        RichIterable\<<name>BooleanPair> notEmpty = this.newWith(<(literal.(type))("1")>, false);
        Verify.assertIterableNotEmpty(notEmpty);
    }

    @Test
    public void aggregateByMutating()
    {
        Function0\<AtomicInteger> valueCreator = Functions0.zeroAtomicInteger();
        Procedure2\<AtomicInteger, <name>BooleanPair> sumAggregator = new Procedure2\<AtomicInteger, <name>BooleanPair>()
        {
            public void value(AtomicInteger aggregate, <name>BooleanPair value)
            {
                aggregate.addAndGet((int) value.getOne());
            }
        };
        RichIterable\<<name>BooleanPair> collection = this.newWith(<(literal.(type))("1")>, false, <(literal.(type))("2")>, true, <(literal.(type))("3")>, false);
        MapIterable\<String, AtomicInteger> aggregation = collection.aggregateInPlaceBy(Functions.getToString(), valueCreator, sumAggregator);
        Assert.assertEquals(3, aggregation.get("<(toStringLiteral.(type))("3")>:false").intValue());
        Assert.assertEquals(2, aggregation.get("<(toStringLiteral.(type))("2")>:true").intValue());
        Assert.assertEquals(1, aggregation.get("<(toStringLiteral.(type))("1")>:false").intValue());
    }

    @Test
    public void aggregateByNonMutating()
    {
        Function0\<Integer> valueCreator = Functions0.value(0);
        Function2\<Integer, <name>BooleanPair, Integer> sumAggregator = new Function2\<Integer, <name>BooleanPair, Integer>()
        {
            public Integer value(Integer aggregate, <name>BooleanPair value)
            {
                return (int) (aggregate + value.getOne());
            }
        };
        RichIterable\<<name>BooleanPair> collection = this.newWith(<(literal.(type))("1")>, false, <(literal.(type))("1")>, false, <(literal.(type))("2")>, true);
        MapIterable\<String, Integer> aggregation = collection.aggregateBy(Functions.getToString(), valueCreator, sumAggregator);
        Assert.assertEquals(2, aggregation.get("<(toStringLiteral.(type))("2")>:true").intValue());
        Assert.assertEquals(1, aggregation.get("<(toStringLiteral.(type))("1")>:false").intValue());
    }
}

>>
