import "copyright.stg"
import "primitiveEquals.stg"
import "primitiveHashCode.stg"
import "primitiveLiteral.stg"

targetPath() ::= "com/gs/collections/impl/map/mutable/primitive"

fileName(primitive) ::= "Boolean<primitive.name>HashMap"

class(primitive, sameTwoPrimitives) ::= <<
<body(primitive.type, primitive.name, sameTwoPrimitives)>
>>

body(type, name, sameTwoPrimitives) ::= <<
<copyright()>

package com.gs.collections.impl.map.mutable.primitive;

import java.io.IOException;
<(arraysImport.(type))()>
import java.util.NoSuchElementException;

import com.gs.collections.api.BooleanIterable;
<if(!sameTwoPrimitives)>import com.gs.collections.api.<name>Iterable;<endif>
import com.gs.collections.api.LazyBooleanIterable;
<if(!sameTwoPrimitives)>import com.gs.collections.api.Lazy<name>Iterable;<endif>
import com.gs.collections.api.RichIterable;
import com.gs.collections.api.bag.primitive.MutableBooleanBag;
<if(!sameTwoPrimitives)>import com.gs.collections.api.bag.primitive.Mutable<name>Bag;<endif>
import com.gs.collections.api.block.function.primitive.BooleanTo<name>Function;
import com.gs.collections.api.block.function.primitive.BooleanToObjectFunction;
import com.gs.collections.api.block.function.primitive.<name>Function;
import com.gs.collections.api.block.function.primitive.<name>Function0;
<if(!sameTwoPrimitives)>import com.gs.collections.api.block.function.primitive.<name>ToObjectFunction;<endif>
<if(!sameTwoPrimitives)>import com.gs.collections.api.block.function.primitive.<name>To<name>Function;<endif>
import com.gs.collections.api.block.predicate.primitive.Boolean<name>Predicate;
import com.gs.collections.api.block.predicate.primitive.BooleanPredicate;
<if(!sameTwoPrimitives)>import com.gs.collections.api.block.predicate.primitive.<name>Predicate;<endif>
import com.gs.collections.api.block.procedure.primitive.Boolean<name>Procedure;
import com.gs.collections.api.block.procedure.primitive.BooleanProcedure;
<if(!sameTwoPrimitives)>import com.gs.collections.api.block.procedure.primitive.<name>Procedure;<endif>
import com.gs.collections.api.iterator.BooleanIterator;
<if(!sameTwoPrimitives)>import com.gs.collections.api.iterator.<name>Iterator;<endif>
import com.gs.collections.api.list.MutableList;
import com.gs.collections.api.list.primitive.MutableBooleanList;
<if(!sameTwoPrimitives)>import com.gs.collections.api.list.primitive.Mutable<name>List;<endif>
import com.gs.collections.api.map.primitive.Boolean<name>Map;
import com.gs.collections.api.map.primitive.MutableBoolean<name>Map;
import com.gs.collections.api.set.primitive.MutableBooleanSet;
<if(!sameTwoPrimitives)>import com.gs.collections.api.set.primitive.Mutable<name>Set;<endif>
import com.gs.collections.impl.bag.mutable.primitive.BooleanHashBag;
<if(!sameTwoPrimitives)>import com.gs.collections.impl.bag.mutable.primitive.<name>HashBag;<endif>
import com.gs.collections.impl.block.factory.primitive.BooleanPredicates;
import com.gs.collections.impl.lazy.primitive.Lazy<name>IterableAdapter;
import com.gs.collections.impl.lazy.primitive.SelectBooleanIterable;
import com.gs.collections.impl.list.mutable.FastList;
import com.gs.collections.impl.list.mutable.primitive.BooleanArrayList;
<if(!sameTwoPrimitives)>import com.gs.collections.impl.list.mutable.primitive.<name>ArrayList;<endif>
import com.gs.collections.impl.set.mutable.primitive.BooleanHashSet;
<if(!sameTwoPrimitives)>import com.gs.collections.impl.set.mutable.primitive.<name>HashSet;<endif>

/**
 * This file was automatically generated from template file booleanPrimitiveHashMap.stg.
 *
 * @since 3.0.
 */
public class Boolean<name>HashMap implements MutableBoolean<name>Map
{
    private static final <type> EMPTY_VALUE = <zero.(type)>;
    private boolean containsTrueKey;
    private boolean containsFalseKey;

    private <type> trueValue;
    private <type> falseValue;

    public static Boolean<name>HashMap newMap()
    {
        return new Boolean<name>HashMap();
    }

    public static Boolean<name>HashMap newWithKeysValues(boolean key, <type> value)
    {
        return new Boolean<name>HashMap().withKeyValue(key, value);
    }

    public static Boolean<name>HashMap newWithKeysValues(boolean key1, <type> value1, boolean key2, <type> value2)
    {
        return new Boolean<name>HashMap().withKeysValues(key1, value1, key2, value2);
    }

    public void clear()
    {
        this.containsFalseKey = false;
        this.falseValue = EMPTY_VALUE;
        this.containsTrueKey = false;
        this.trueValue = EMPTY_VALUE;
    }

    public void put(boolean key, <type> value)
    {
        if (key)
        {
            this.containsTrueKey = true;
            this.trueValue = value;
        }
        else
        {
            this.containsFalseKey = true;
            this.falseValue = value;
        }
    }

    public <type> get(boolean key)
    {
        return key ? this.trueValue : this.falseValue;
    }

    public <type> getOrThrow(boolean key)
    {
        if (key)
        {
            if (this.containsTrueKey)
            {
                return this.trueValue;
            }
        }
        else
        {
            if (this.containsFalseKey)
            {
                return this.falseValue;
            }
        }
        throw new IllegalStateException("Key " + key + " not present.");
    }

    public <type> getIfAbsentPut(boolean key, <type> value)
    {
        if (key)
        {
            if (this.containsTrueKey)
            {
                return this.trueValue;
            }
            this.containsTrueKey = true;
            this.trueValue = value;
            return this.trueValue;
        }
        if (this.containsFalseKey)
        {
            return this.falseValue;
        }
        this.containsFalseKey = true;
        this.falseValue = value;
        return this.falseValue;
    }

    public <type> getIfAbsentPut(boolean key, <name>Function0 function)
    {
        if (key)
        {
            if (this.containsTrueKey)
            {
                return this.trueValue;
            }
            this.containsTrueKey = true;
            this.trueValue = function.value();
            return this.trueValue;
        }
        if (this.containsFalseKey)
        {
            return this.falseValue;
        }
        this.containsFalseKey = true;
        this.falseValue = function.value();
        return this.falseValue;
    }

    public \<P> <type> getIfAbsentPutWith(boolean key, <name>Function\<? super P> function, P parameter)
    {
        if (key)
        {
            if (this.containsTrueKey)
            {
                return this.trueValue;
            }
            this.containsTrueKey = true;
            this.trueValue = function.<type>ValueOf(parameter);
            return this.trueValue;
        }
        if (this.containsFalseKey)
        {
            return this.falseValue;
        }
        this.containsFalseKey = true;
        this.falseValue = function.<type>ValueOf(parameter);
        return this.falseValue;
    }

    public <type> getIfAbsentPutWithKey(boolean key, BooleanTo<name>Function function)
    {
        if (key)
        {
            if (this.containsTrueKey)
            {
                return this.trueValue;
            }
            this.containsTrueKey = true;
            this.trueValue = function.valueOf(true);
            return this.trueValue;
        }
        if (this.containsFalseKey)
        {
            return this.falseValue;
        }
        this.containsFalseKey = true;
        this.falseValue = function.valueOf(false);
        return this.falseValue;
    }

    public <type> updateValue(boolean key, <type> initialValueIfAbsent, <name>To<name>Function function)
    {
        if (key)
        {
            if (this.containsTrueKey)
            {
                this.trueValue = function.valueOf(this.trueValue);
            }
            else
            {
                this.containsTrueKey = true;
                this.trueValue = function.valueOf(initialValueIfAbsent);
            }
            return this.trueValue;
        }
        if (this.containsFalseKey)
        {
            this.falseValue = function.valueOf(this.falseValue);
        }
        else
        {
            this.containsFalseKey = true;
            this.falseValue = function.valueOf(initialValueIfAbsent);
        }
        return this.falseValue;
    }

    public void removeKey(boolean key)
    {
        if (key)
        {
            this.containsTrueKey = false;
            this.trueValue = EMPTY_VALUE;
        }
        else
        {
            this.containsFalseKey = false;
            this.falseValue = EMPTY_VALUE;
        }
    }

    public <type> removeKeyIfAbsent(boolean key, <type> value)
    {
        if (key)
        {
            if (this.containsTrueKey)
            {
                <type> oldValue = this.trueValue;
                this.containsTrueKey = false;
                this.trueValue = EMPTY_VALUE;
                return oldValue;
            }
            return value;
        }
        if (this.containsFalseKey)
        {
            <type> oldValue = this.falseValue;
            this.containsFalseKey = false;
            this.falseValue = EMPTY_VALUE;
            return oldValue;
        }
        return value;
    }

    public boolean containsKey(boolean key)
    {
        return key ? this.containsTrueKey : this.containsFalseKey;
    }

    public boolean containsValue(<type> value)
    {
        return (this.containsFalseKey && <(equals.(type))("this.falseValue", "value")>)
                || (this.containsTrueKey && <(equals.(type))("this.trueValue", "value")>);
    }

    public void forEachValue(<name>Procedure procedure)
    {
        if (this.containsFalseKey)
        {
            procedure.value(this.falseValue);
        }
        if (this.containsTrueKey)
        {
            procedure.value(this.trueValue);
        }
    }

    public void forEachKey(BooleanProcedure procedure)
    {
        if (this.containsFalseKey)
        {
            procedure.value(false);
        }
        if (this.containsTrueKey)
        {
            procedure.value(true);
        }
    }

    public void forEachKeyValue(Boolean<name>Procedure procedure)
    {
        if (this.containsFalseKey)
        {
            procedure.value(false, this.falseValue);
        }
        if (this.containsTrueKey)
        {
            procedure.value(true, this.trueValue);
        }
    }

    public LazyBooleanIterable keysView()
    {
        return new KeysView();
    }

    public Boolean<name>HashMap select(Boolean<name>Predicate predicate)
    {
        Boolean<name>HashMap map = Boolean<name>HashMap.newMap();
        if (this.containsFalseKey && predicate.accept(false, this.falseValue))
        {
            map.put(false, this.falseValue);
        }
        if (this.containsTrueKey && predicate.accept(true, this.trueValue))
        {
            map.put(true, this.trueValue);
        }
        return map;
    }

    public Boolean<name>HashMap reject(Boolean<name>Predicate predicate)
    {
        Boolean<name>HashMap map = Boolean<name>HashMap.newMap();
        if (this.containsFalseKey && !predicate.accept(false, this.falseValue))
        {
            map.put(false, this.falseValue);
        }
        if (this.containsTrueKey && !predicate.accept(true, this.trueValue))
        {
            map.put(true, this.trueValue);
        }
        return map;
    }

    public int size()
    {
        return (this.containsFalseKey ? 1 : 0) + (this.containsTrueKey ? 1 : 0);
    }

    public boolean isEmpty()
    {
        return !this.containsFalseKey && !this.containsTrueKey;
    }

    public boolean notEmpty()
    {
        return this.containsFalseKey || this.containsTrueKey;
    }

    @Override
    public boolean equals(Object obj)
    {
        if (this == obj)
        {
            return true;
        }

        if (!(obj instanceof Boolean<name>Map))
        {
            return false;
        }

        Boolean<name>Map other = (Boolean<name>Map) obj;

        if (this.size() != other.size())
        {
            return false;
        }

        if (this.containsFalseKey && (!other.containsKey(false) || <(notEquals.(type))("this.falseValue", "other.get(false)")>))
        {
            return false;
        }

        if (this.containsTrueKey && (!other.containsKey(true) || <(notEquals.(type))("this.trueValue", "other.get(true)")>))
        {
            return false;
        }

        return true;
    }

    @Override
    public int hashCode()
    {
        int result = 0;

        if (this.containsFalseKey)
        {
            result += 1237 ^ <(hashCode.(type))("this.falseValue")>;
        }

        if (this.containsTrueKey)
        {
            result += 1231 ^ <(hashCode.(type))("this.trueValue")>;
        }

        return result;
    }

    @Override
    public String toString()
    {
        return this.makeString("[", ", ", "]");
    }

    public String makeString()
    {
        return this.makeString(", ");
    }

    public String makeString(String separator)
    {
        return this.makeString("", separator, "");
    }

    public String makeString(String start, String separator, String end)
    {
        Appendable stringBuilder = new StringBuilder();
        this.appendString(stringBuilder, start, separator, end);
        return stringBuilder.toString();
    }

    public void appendString(Appendable appendable)
    {
        this.appendString(appendable, ", ");
    }

    public void appendString(Appendable appendable, String separator)
    {
        this.appendString(appendable, "", separator, "");
    }

    public void appendString(Appendable appendable, String start, String separator, String end)
    {
        try
        {
            appendable.append(start);

            if (this.containsFalseKey)
            {
                appendable.append("false=").append(String.valueOf(this.falseValue));
            }
            if (this.containsTrueKey)
            {
                if (this.containsFalseKey)
                {
                    appendable.append(separator);
                }
                appendable.append("true=").append(String.valueOf(this.trueValue));
            }
            appendable.append(end);
        }
        catch (IOException e)
        {
            throw new RuntimeException(e);
        }
    }

    public Boolean<name>HashMap withKeyValue(boolean key, <type> value)
    {
        this.put(key, value);
        return this;
    }

    public Boolean<name>HashMap withKeysValues(boolean key1, <type> value1, boolean key2, <type> value2)
    {
        this.put(key1, value1);
        this.put(key2, value2);
        return this;
    }
    
    public Boolean<name>HashMap withoutKey(boolean key)
    {
        this.removeKey(key);
        return this;
    }

    public Boolean<name>HashMap withoutAllKeys(BooleanIterable keys)
    {
        keys.forEach(new BooleanProcedure()
        {
            public void value(boolean each)
            {
                Boolean<name>HashMap.this.removeKey(each);
            }
        });
        return this;
    }

    public <name>Iterator <type>Iterator()
    {
        return new Internal<name>Iterator();
    }

    public void forEach(<name>Procedure procedure)
    {
        this.forEachValue(procedure);
    }

    public int count(<name>Predicate predicate)
    {
        int count = 0;
        if (this.containsFalseKey && predicate.accept(this.falseValue))
        {
            count++;
        }
        if (this.containsTrueKey && predicate.accept(this.trueValue))
        {
            count++;
        }
        return count;
    }

    public boolean anySatisfy(<name>Predicate predicate)
    {
        return (this.containsFalseKey && predicate.accept(this.falseValue)) || (this.containsTrueKey && predicate.accept(this.trueValue));
    }

    public boolean allSatisfy(<name>Predicate predicate)
    {
        if (this.containsFalseKey && !predicate.accept(this.falseValue))
        {
            return false;
        }
        return !(this.containsTrueKey && !predicate.accept(this.trueValue));
    }

    public <name>Iterable select(<name>Predicate predicate)
    {
        <name>ArrayList list = new <name>ArrayList();
        if (this.containsFalseKey && predicate.accept(this.falseValue))
        {
            list.add(this.falseValue);
        }
        if (this.containsTrueKey && predicate.accept(this.trueValue))
        {
            list.add(this.trueValue);
        }
        return list;
    }

    public <name>Iterable reject(<name>Predicate predicate)
    {
        <name>ArrayList list = new <name>ArrayList();
        if (this.containsFalseKey && !predicate.accept(this.falseValue))
        {
            list.add(this.falseValue);
        }
        if (this.containsTrueKey && !predicate.accept(this.trueValue))
        {
            list.add(this.trueValue);
        }
        return list;
    }

    public <type> detectIfNone(<name>Predicate predicate, <type> ifNone)
    {
        if (this.containsFalseKey && predicate.accept(this.falseValue))
        {
            return this.falseValue;
        }
        if (this.containsTrueKey && predicate.accept(this.trueValue))
        {
            return this.trueValue;
        }
        return ifNone;
    }

    public \<V> RichIterable\<V> collect(<name>ToObjectFunction\<? extends V> function)
    {
        MutableList\<V> result = FastList.newList(this.size());
        if (this.containsFalseKey)
        {
            result.add(function.valueOf(this.falseValue));
        }
        if (this.containsTrueKey)
        {
            result.add(function.valueOf(this.trueValue));
        }
        return result;
    }

    <(arithmeticMethods.(type))(type)>

    public <type>[] toArray()
    {
        <type>[] result = new <type>[this.size()];
        int index = 0;

        if (this.containsFalseKey)
        {
            result[index] = this.falseValue;
            index++;
        }
        if (this.containsTrueKey)
        {
            result[index] = this.trueValue;
        }
        return result;
    }

    public boolean contains(<type> value)
    {
        return this.containsValue(value);
    }

    public boolean containsAll(<type>... source)
    {
        for (<type> value : source)
        {
            if (!this.containsValue(value))
            {
                return false;
            }
        }
        return true;
    }

    public boolean containsAll(<name>Iterable source)
    {
        return this.containsAll(source.toArray());
    }

    public Mutable<name>List toList()
    {
        Mutable<name>List result = new <name>ArrayList(this.size());
        if (this.containsFalseKey)
        {
            result.add(this.falseValue);
        }
        if (this.containsTrueKey)
        {
            result.add(this.trueValue);
        }
        return result;
    }

    public Mutable<name>List toSortedList()
    {
        return this.toList().sortThis();
    }

    public Mutable<name>Set toSet()
    {
        Mutable<name>Set result = new <name>HashSet();
        if (this.containsFalseKey)
        {
            result.add(this.falseValue);
        }
        if (this.containsTrueKey)
        {
            result.add(this.trueValue);
        }
        return result;
    }

    public Mutable<name>Bag toBag()
    {
        Mutable<name>Bag result = new <name>HashBag();
        if (this.containsFalseKey)
        {
            result.add(this.falseValue);
        }
        if (this.containsTrueKey)
        {
            result.add(this.trueValue);
        }
        return result;
    }

    public Lazy<name>Iterable asLazy()
    {
        return new Lazy<name>IterableAdapter(this);
    }

    private class Internal<name>Iterator implements <name>Iterator
    {
        private boolean handledFalse;
        private boolean handledTrue;

        public boolean hasNext()
        {
            return !this.handledFalse && Boolean<name>HashMap.this.containsFalseKey || !this.handledTrue && Boolean<name>HashMap.this.containsTrueKey;
        }

        public <type> next()
        {
            if (!this.handledFalse && Boolean<name>HashMap.this.containsFalseKey)
            {
                this.handledFalse = true;
                return Boolean<name>HashMap.this.falseValue;
            }
            if (!this.handledTrue && Boolean<name>HashMap.this.containsTrueKey)
            {
                this.handledTrue = true;
                return Boolean<name>HashMap.this.trueValue;
            }
            throw new NoSuchElementException("next() called, but the iterator is exhausted");
        }
    }
    
    private class KeysView implements LazyBooleanIterable
    {
        public boolean isEmpty()
        {
            return Boolean<name>HashMap.this.isEmpty();
        }

        public boolean notEmpty()
        {
            return Boolean<name>HashMap.this.notEmpty();
        }

        public int size()
        {
            return Boolean<name>HashMap.this.size();
        }

        public boolean contains(boolean key)
        {
            return Boolean<name>HashMap.this.containsKey(key);
        }

        public boolean containsAll(boolean... keys)
        {
            for (boolean key : keys)
            {
                if (!Boolean<name>HashMap.this.containsKey(key))
                {
                    return false;
                }
            }
            return true;
        }

        public boolean containsAll(BooleanIterable source)
        {
            return source.allSatisfy(new BooleanPredicate()
            {
                public boolean accept(boolean key)
                {
                    return Boolean<name>HashMap.this.containsKey(key);
                }
            });
        }

        public BooleanIterator booleanIterator()
        {
            return new KeySetIterator();
        }

        public void forEach(BooleanProcedure procedure)
        {
            Boolean<name>HashMap.this.forEachKey(procedure);
        }

        public String makeString()
        {
            return this.makeString(", ");
        }

        public String makeString(String separator)
        {
            return this.makeString("", separator, "");
        }

        public String makeString(String start, String separator, String end)
        {
            Appendable stringBuilder = new StringBuilder();
            this.appendString(stringBuilder, start, separator, end);
            return stringBuilder.toString();
        }

        public void appendString(Appendable appendable)
        {
            this.appendString(appendable, ", ");
        }

        public void appendString(Appendable appendable, String separator)
        {
            this.appendString(appendable, "", separator, "");
        }

        public void appendString(Appendable appendable, String start, String separator, String end)
        {
            try
            {
                appendable.append(start);
                boolean first = true;
                if (Boolean<name>HashMap.this.containsFalseKey)
                {
                    appendable.append(String.valueOf(false));
                    first = false;
                }
                if (Boolean<name>HashMap.this.containsTrueKey)
                {
                    if (!first)
                    {
                        appendable.append(separator);
                    }
                    appendable.append(String.valueOf(true));
                }
                appendable.append(end);
            }
            catch (IOException e)
            {
                throw new RuntimeException(e);
            }
        }

        public int count(BooleanPredicate predicate)
        {
            int count = 0;
            if (Boolean<name>HashMap.this.containsFalseKey && predicate.accept(false))
            {
                count++;
            }
            if (Boolean<name>HashMap.this.containsTrueKey && predicate.accept(true))
            {
                count++;
            }
            return count;
        }

        public boolean anySatisfy(BooleanPredicate predicate)
        {
            if (Boolean<name>HashMap.this.containsFalseKey && predicate.accept(false))
            {
                return true;
            }
            if (Boolean<name>HashMap.this.containsTrueKey && predicate.accept(true))
            {
                return true;
            }
            return false;
        }

        public boolean allSatisfy(BooleanPredicate predicate)
        {
            if (Boolean<name>HashMap.this.containsFalseKey && !predicate.accept(false))
            {
                return false;
            }
            if (Boolean<name>HashMap.this.containsTrueKey && !predicate.accept(true))
            {
                return false;
            }
            return true;
        }

        public LazyBooleanIterable select(BooleanPredicate predicate)
        {
            return new SelectBooleanIterable(this, predicate);
        }

        public LazyBooleanIterable reject(BooleanPredicate predicate)
        {
            return new SelectBooleanIterable(this, BooleanPredicates.not(predicate));
        }

        public boolean detectIfNone(BooleanPredicate predicate, boolean value)
        {
            if (Boolean<name>HashMap.this.containsFalseKey && predicate.accept(false))
            {
                return false;
            }
            if (Boolean<name>HashMap.this.containsTrueKey && predicate.accept(true))
            {
                return true;
            }
            return value;
        }

        public \<V> RichIterable\<V> collect(BooleanToObjectFunction\<? extends V> function)
        {
            FastList\<V> target = FastList.newList(this.size());
            if (Boolean<name>HashMap.this.containsFalseKey)
            {
                target.add(function.valueOf(false));
            }
            if (Boolean<name>HashMap.this.containsTrueKey)
            {
                target.add(function.valueOf(true));
            }
            return target;
        }

        public boolean[] toArray()
        {
            int size = Boolean<name>HashMap.this.size();
            final boolean[] result = new boolean[size];
            Boolean<name>HashMap.this.forEachKey(new BooleanProcedure()
            {
                private int index;

                public void value(boolean each)
                {
                    result[this.index] = each;
                    this.index++;
                }
            });
            return result;
        }

        public MutableBooleanList toList()
        {
            return BooleanArrayList.newList(this);
        }

        public MutableBooleanList toSortedList()
        {
            return BooleanArrayList.newList(this).sortThis();
        }

        public MutableBooleanSet toSet()
        {
            return BooleanHashSet.newSet(this);
        }

        public MutableBooleanBag toBag()
        {
            return BooleanHashBag.newBag(this);
        }

        public LazyBooleanIterable asLazy()
        {
            return this;
        }
    }

    private class KeySetIterator implements BooleanIterator
    {
        private boolean handledTrue;
        private boolean handledFalse;

        public boolean hasNext()
        {
            return !this.handledFalse && Boolean<name>HashMap.this.containsFalseKey
                    || !this.handledTrue && Boolean<name>HashMap.this.containsTrueKey;
        }

        public boolean next()
        {
            if (!this.handledFalse && Boolean<name>HashMap.this.containsFalseKey)
            {
                this.handledFalse = true;
                return false;
            }
            if (!this.handledTrue && Boolean<name>HashMap.this.containsTrueKey)
            {
                this.handledTrue = true;
                return true;
            }
            throw new NoSuchElementException("next() called, but the iterator is exhausted");
        }
    }
}

>>

arraysImport ::= [
    "boolean": "none",
    "byte": "arrays",
    "short": "arrays",
    "char": "arrays",
    "int": "arrays",
    "long": "arrays",
    "float": "arrays",
    "double": "arrays"
    ]

none() ::= ""

arrays() ::= "import java.util.Arrays;"

arithmeticMethods ::= [
    "boolean": "noMethods",
    "byte": "allMethods",
    "short": "allMethods",
    "char": "allMethods",
    "int": "allMethods",
    "long": "allMethods",
    "float": "allMethods",
    "double": "allMethods"
    ]

noMethods(type) ::= ""

allMethods(type) ::= <<
public <wideType.(type)> sum()
{
    <wideType.(type)> sum = <wideZero.(type)>;
    if (this.containsFalseKey)
    {
        sum += this.falseValue;
    }
    if (this.containsTrueKey)
    {
        sum += this.trueValue;
    }
    return sum;
}

public <type> max()
{
    if (this.isEmpty())
    {
        throw new NoSuchElementException();
    }

    if (this.containsTrueKey)
    {
        if (this.containsFalseKey)
        {
            return <(lessThan.(type))("this.falseValue", "this.trueValue")> ? this.trueValue : this.falseValue;
        }
        return this.trueValue;
    }

    return this.falseValue;
}

public <type> maxIfEmpty(<type> defaultValue)
{
    if (this.isEmpty())
    {
        return defaultValue;
    }

    if (this.containsTrueKey)
    {
        if (this.containsFalseKey)
        {
            return <(lessThan.(type))("this.falseValue", "this.trueValue")> ? this.trueValue : this.falseValue;
        }
        return this.trueValue;
    }

    return this.falseValue;
}

public <type> min()
{
    if (this.isEmpty())
    {
        throw new NoSuchElementException();
    }

    if (this.containsTrueKey)
    {
        if (this.containsFalseKey)
        {
            return <(lessThan.(type))("this.trueValue", "this.falseValue")> ? this.trueValue : this.falseValue;
        }
        return this.trueValue;
    }

    return this.falseValue;
}

public <type> minIfEmpty(<type> defaultValue)
{
    if (this.isEmpty())
    {
        return defaultValue;
    }

    if (this.containsTrueKey)
    {
        if (this.containsFalseKey)
        {
            return <(lessThan.(type))("this.trueValue", "this.falseValue")> ? this.trueValue : this.falseValue;
        }
        return this.trueValue;
    }

    return this.falseValue;
}

public double average()
{
    return <castSum.(type)>this.sum() / (double) this.size();
}

public double median()
{
    if (this.isEmpty())
    {
        throw new NoSuchElementException();
    }

    if (this.containsTrueKey)
    {
        if (this.containsFalseKey)
        {
            return (<castDouble.(type)>this.trueValue + <castDouble.(type)>this.falseValue) / 2.0;
        }
        return <castDouble.(type)>this.trueValue;
    }

    return <castDouble.(type)>this.falseValue;
}

public <type>[] toSortedArray()
{
    <type>[] array = this.toArray();
    Arrays.sort(array);
    return array;
}
>>
